#' @description
#' Generates list of options for a SAGA-GIS tool
#'
#' @details
#' Parses the html table for a SAGA-GIS tool into a list of identifiers,
#' options, defaults and constraints
#'
#' @keywords internal
SagaTool = R6::R6Class(
  classname = "SagaTool",
  
  public = list(
    #' @field tool_name A syntactically-correct name for the tool.
    tool_name = NULL,
    
    #' @field description The tool's description.
    description = NULL,
    
    #' @field author The tool's author.
    author = NULL,
    
    #' @field tool_cmd The command to use for saga_cmd to execute tool.
    tool_cmd = NULL,

    #' @field tool_id The tool's id. The integer identifier for the tool within
    #' its module, i.e., ta_hydrology 4 refers to the Upslope Area tool.
    tool_id = NULL,
    
    #' @field parameters A named list of the tool's `Parameter` objects.
    parameters = NULL,
    
    #' @field html_file The html document name.
    html_file = NULL,
    
    #' @field verbose Whether to provide a higher level of verbosity by
    #'   providing messages relating to the call to the SAGA command line tool
    #'   and displaying any messages that SAGA-GIS itself produces. This can be
    #'   useful for debugging. The default is FALSE.
    verbose = FALSE,
    
    #' @field intern Whether to return the output from the SAGA command line.
    #'   The default is TRUE.
    intern = TRUE,
    
    #' @field all_outputs Weather to automatically use temporary files to 
    #' collect all outputs that the tool can produce. The default is FALSE.
    all_outputs = FALSE,

    #' @field temp_path Path to use for temporary files. The default is the
    #' path that is generated by tempdir().
    temp_path = tempdir(),
    
    #' @description
    #' Creates a new SagaTool R6 class object.
    #' 
    #' @param tool_information list
    #' @param tool_options list
    #' @param description The description text for the tool that has been 
    #' scraped from the help documentation.
    #' @param html_file the name of the html file for the tool's documentation.
    #' This is stored to help linking with online documentation.
    initialize = function(tool_information, tool_options, description, html_file) {
      # parse the command to execute the saga_cmd tool
      saga_tool_cmd = tool_information[[2]][1]
      author = tool_information[[2]][2]
    
      # create syntactically-correct name for the tool
      tool_name = gsub("^[0-9]+", "", saga_tool_cmd)
      tool_name = gsub("^[0-9]+", "", tool_name)
      tool_name = gsub(" ", "_", tool_name)
      tool_name = gsub("\\(", "", tool_name)
      tool_name = gsub("\\)", "", tool_name)
      tool_name = gsub("\\(", "", tool_name)
      tool_name = gsub("\\)", "", tool_name)
      tool_name = gsub("'", "", tool_name)
      tool_name = gsub(",", "_", tool_name)
      tool_name = gsub("/", "_", tool_name)
      tool_name = gsub("-", "_", tool_name)
      tool_name = gsub(":", "_", tool_name)
      tool_name = gsub("\\[", "_", tool_name)
      tool_name = gsub("\\]", "_", tool_name)
      tool_name = gsub("&", "_", tool_name)
      tool_name = gsub("_+", "_", tool_name)
      tool_name = gsub("^_+", "", tool_name)
      tool_name = tolower(tool_name)
      
      # get the tool ID
      tool_id = tool_information[tool_information[[1]] == "ID",][[2]]
      suppressWarnings({tool_id = as.integer(tool_id)})
      if (is.na(tool_id)) {
        tool_id = saga_tool_cmd
      }
    
      # strip input, output and options lines from table
      # (rows in the table that represent headers/section breaks and have same value
      # like 'Input' filled across the row)
      header_rows = apply(tool_options, 1, function(row) {
        length(unique(unlist(row)))
      })
      header_rows = which(header_rows > 1)
      tool_options = tool_options[header_rows, ]
    
      # get the parameters object
      params = self$create_parameters_class(tool_name, tool_options)
      parameters = params$new()

      # apply exceptions for specific saga-gis tools
      # params = create_tool_overrides(tool_name, params)
  
      # update the class fields
      self$tool_name = tool_name
      self$description = description
      self$author = author
      self$tool_cmd = saga_tool_cmd
      self$tool_id = tool_id
      self$parameters = parameters
      self$html_file = html_file
    }, 
    
    create_alias = function(identifier) {
      alias = identifier
      if (grepl("^[[:digit:]]", identifier)) alias = paste0("x", identifier)
      alias = gsub(" ", "_", alias)
      alias = tolower(alias)
      make.names(alias, unique = TRUE)
    },
    
    create_parameters_class = function(tool_name, tool_options) {
      # replace tool arguments with syntactically-correct version
      tool_identifiers = tool_options$Identifier
      tool_aliases = sapply(tool_identifiers, self$create_alias)
      tool_aliases = make.names(tool_aliases, unique = TRUE)
      
      # convert options table to nested list
      params = rep(list(NA), nrow(tool_options))
      params = stats::setNames(params, tool_aliases)
      ToolParams = R6::R6Class(tool_name, inherit = Parameters_class)
      
      for (i in seq_len(length(tool_aliases))) {
        alias = tool_aliases[[i]]
        identifier = tool_identifiers[[i]]
        
        new_param = Parameter$new(
          type = tool_options[tool_options$Identifier == identifier, ][["Type"]],
          name = tool_options[tool_options$Identifier == identifier, ][["Name"]],
          alias = alias,
          identifier = identifier,
          description = tool_options[tool_options$Identifier == identifier, ][["Description"]],
          constraints = tool_options[tool_options$Identifier == identifier, ][["Constraints"]]
        )
        ToolParams$set("public", alias, new_param)
      }
      return(ToolParams)
    },
    
    run = function(.intern = NULL, .all_outputs = NULL, .verbose = NULL, ...) {
      args = c(...)
      
      # get tool and saga settings
      tools_in_library = senv$libraries[[lib]]
      selected_tool = tools_in_library[[tool]]
      params = selected_tool$params
      tool_cmd = selected_tool$tool_cmd
      saga_cmd = senv$saga_cmd
      saga_config = senv$saga_config
      temp_path = senv$temp_path
      raster_backend = senv$raster_backend
      vector_backend = senv$vector_backend
      verbose = senv$verbose
      intern = senv$intern
      all_outputs = senv$all_outputs
      raster_format = senv$raster_format
      vector_format = senv$vector_format
      
      # override saga object options with those supplied from tool
      if (!is.null(.verbose)) {
        verbose = .verbose
      }
      
      if (!is.null(.intern)) {
        intern = .intern
      }
      
      if (!is.null(.all_outputs)) {
        all_outputs = .all_outputs
      }
      
      # update parameters object with argument values
      for (arg_name in names(args)) {
        if (arg_name %in% names(params)) {
          params[[arg_name]]$value = args[[arg_name]]
        }
      }
      
      # save in-memory R objects to files for saga_cmd to access
      params =
        update_parameters_file(params, temp_path, raster_format, vector_format)
      
      # optionally use tempfiles for unspecified outputs
      if (all_outputs == TRUE) {
        params = update_parameters_tempfiles(
          params, temp_path, raster_format,
          vector_format
        )
      }
      
      # remove unused parameter objects
      params = drop_parameters(params)
      
      if (length(params) == 0) {
        stop("No outputs have been specified")
      }
      
      # check if any outputs will be produced
      parameters_io = lapply(params, function(x) if (!is.na(x$io)) x)
      parameters_io = parameters_io[!sapply(parameters_io, is.null)]
      
      if (length(parameters_io) > 0) {
        tool_outputs = lapply(parameters_io, function(x) {
          if (x$io == "Output" && !is.null(x$files)) {
            return(x)
          }
        })
        
        tool_outputs = tool_outputs[!sapply(tool_outputs, is.null)]
        
        n_outputs = length(tool_outputs)
      } else {
        n_outputs = 0
      }
      
      # check that output formats are supported
      if (n_outputs > 0) {
        for (tool_output in tool_outputs) {
          check_output_format(tool_output, raster_format, vector_format)
        }
      } else {
        stop("No outputs have been specified")
        return(NULL)
      }
      
      # update the arguments and expected outputs for tool
      cmd_args = sapply(params, function(param) param[["files"]])
      cmd_args = stats::setNames(
        cmd_args, sapply(params, function(param) param[["identifier"]])
      )
      
      # execute system call
      msg = run_cmd(saga_cmd, saga_config, lib, tool_cmd, cmd_args, verbose)
      
      if (msg$status == 1) {
        if (verbose) {
          message(msg$stdout)
        }
        stop(msg$stderr)
      }
      
      # load SAGA results as list of R objects
      saga_results =
        lapply(
          tool_outputs,
          read_output,
          raster_backend = raster_backend,
          vector_backend = vector_backend,
          .intern = intern,
          .all_outputs = all_outputs
        )
      
      # discard nulls
      saga_results = saga_results[!sapply(saga_results, is.null)]
      
      # summarize outputs
      if (length(saga_results) == 1) {
        saga_results = saga_results[[1]]
      }
      
      saga_results
    }
    
    # describe = function(tool_obj) {
    #   params <- tool_obj[["params"]]
    #   
    #   for (i in names(saga$library$ta_morphometry$terrain_ruggedness_index_tri$parameters)) {
    #     print(saga$library$ta_morphometry$terrain_ruggedness_index_tri$parameters[[i]]$name)
    #   }
    #   
    #   df <- tibble::tibble(
    #     parameter = sapply(params, function(x) x$name),
    #     type = sapply(params, function(x) x$type),
    #     argument = sapply(params, function(x) x$alias),
    #     identifier = sapply(params, function(x) x$identifier),
    #     description = sapply(params, function(x) {
    #       ifelse(x$description == "", NA_character_, x$description)
    #     }),
    #     default = sapply(params, function(x) x$default),
    #     available_opts = sapply(params, function(param) {
    #       constraints <- param$constraints[!is.na(param$constraints)]
    #       
    #       ifelse(length(constraints) > 0,
    #              paste(constraints, collapse = "; "),
    #              constraints
    #       )
    #     })
    #   )
    #   
    #   df
    # },
    
    # print = function(x, ...) {
    #   tool_obj <- self$extract_tool(x)
    #   lib <- attr(x, "lib")
    #   tool <- attr(x, "tool")
    #   
    #   author <- tool_obj[["author"]]
    #   description <- tool_obj[["description"]]
    #   
    #   cat(paste0("Help for library = ", lib, "; tool = ", tool, ":", "\n"))
    #   cat(paste0("Author: n", author), "\n")
    #   cat(paste0("Description: ", description), "\n")
    #   cat("\n")
    #   
    #   df <- self$summarize_tool_params(tool_obj)
    #   print(df)
    # }

  )
)
